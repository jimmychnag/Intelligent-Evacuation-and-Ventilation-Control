C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TEST_COMBINE
OBJECT MODULE PLACED IN .\test_combine.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\test\test_combine.c BROWSE DEBUG OBJECTEXTEND PRINT(.\test_combine.lst) 
                    -TABS(2) OBJECT(.\test_combine.obj)

line level    source

   1          #include <regx51.h>
   2          #define LED P0
   3          #define BUZZER P3_4
   4          bit dir;
   5          void delay(unsigned int time) { while(time>0) time--;}
   6          
   7          //--Servo PWM---
   8          unsigned int dutytime_Servo=55536; //65536 - 45536 = 20000
   9          unsigned int ton_Servo=10000; 
  10          unsigned int toff_Servo=10000; 
  11          unsigned int temp_Servo; //當頻率過高時，要用temp優化，避免值算錯誤
  12          //--------------
  13          
  14          
  15          bit flag1 = 0;
  16          bit flag2 = 0;
  17          
  18          
  19          //----I2C LCD---
  20          #define SLAVE 0x4E //0x27 << 1
  21          sbit scl = P1^7;
  22          sbit sda = P1^6;
  23          void scl_w(bit value)
  24          {
  25   1          if(value == 0)
  26   1          {
  27   2            scl = 0;
  28   2            delay(5);
  29   2          }
  30   1          else
  31   1          {
  32   2            scl = 1;
  33   2            delay(5);
  34   2          }
  35   1      }
  36          
  37          void sda_w(bit value)
  38          {
  39   1          if(value == 0)
  40   1          {
  41   2            sda = 0;
  42   2            delay(5);
  43   2          }
  44   1          else
  45   1          {
  46   2            sda = 1;
  47   2            delay(5);
  48   2          }
  49   1      }
  50          
  51          bit sda_r(void)
  52          {
  53   1          bit value;
  54   1          value = sda;
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 2   

  55   1          delay(5);
  56   1          return value;
  57   1      }
  58          
  59          void start()
  60          {
  61   1          scl_w(1);
  62   1          sda_w(1);
  63   1          sda_w(0);
  64   1          scl_w(0);
  65   1      }
  66          
  67          void send_8bits(unsigned char value)
  68          {
  69   1          unsigned char i ;
  70   1          for(i = 0 ; i < 8 ; i++)
  71   1          {
  72   2            sda_w( !!( value & (0x80 >> i) ));
  73   2            scl_w(1);
  74   2            scl_w(0);
  75   2          }
  76   1      }
  77          
  78          bit ack_receive(void)
  79          {
  80   1          bit value;
  81   1      
  82   1          sda_w(1);
  83   1          
  84   1          scl_w(1);
  85   1          value = sda_r();
  86   1          scl_w(0);
  87   1          return value;
  88   1      }
  89          
  90          void ack_send(void)
  91          {
  92   1          scl_w(0);
  93   1          sda_w(0);
  94   1          scl_w(1);
  95   1          scl_w(0);
  96   1      }
  97          
  98          void stop(void)
  99          {
 100   1          sda_w(0);
 101   1          scl_w(1);
 102   1          sda_w(1);
 103   1      }
 104          
 105          void WriteInst4bits(unsigned char inst_4b)
 106          {
 107   1          start();
 108   1          send_8bits(SLAVE);  
 109   1          ack_receive();
 110   1          send_8bits(0x0C);         //EN=1 RW=0 RS=0
 111   1          ack_receive();
 112   1          send_8bits((inst_4b&0xF0)+0x0C); //??D7-D4
 113   1          ack_receive();
 114   1          send_8bits(0x08); //EN=0 ?????
 115   1          ack_receive();
 116   1          stop();
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 3   

 117   1      }
 118          
 119          void WriteInst(unsigned char inst)
 120          { 
 121   1          start();
 122   1          send_8bits(SLAVE);  
 123   1          ack_receive();
 124   1          send_8bits(0x0C);         //EN=1 RW=0 RS=1
 125   1          ack_receive();
 126   1          send_8bits((inst&0xF0)+0x0C);   //???
 127   1          ack_receive();
 128   1          send_8bits(0x08);   //EN=0 ????
 129   1          ack_receive();
 130   1      
 131   1          send_8bits(0x0C);         //EN=1
 132   1          ack_receive();
 133   1          send_8bits((inst<<4)+0x0C);    //???
 134   1          ack_receive();
 135   1          send_8bits(0x08);    //EN=0 ????
 136   1          ack_receive();
 137   1          stop();
 138   1      } 
 139          
 140          void WriteData(unsigned char data_)
 141          {
 142   1          start();
 143   1          send_8bits(SLAVE);  
 144   1          ack_receive();
 145   1        
 146   1          send_8bits(0x0D);         //EN=1 RW=0 RS=1
 147   1          ack_receive();
 148   1          send_8bits((data_&0xF0)+0x0D);  
 149   1          ack_receive();
 150   1          send_8bits(0x09);  
 151   1          ack_receive();
 152   1        
 153   1          send_8bits(0x0D);         //EN=1 RW=0 RS=1
 154   1          ack_receive();
 155   1          send_8bits((data_<<4)+0x0D);   
 156   1          ack_receive();
 157   1          send_8bits(0x09);   
 158   1          ack_receive();
 159   1          
 160   1          stop();
 161   1      } 
 162          
 163          void WriteString(unsigned char* string)
 164          {
 165   1          while(*string )
 166   1          {
 167   2            WriteData(*string);
 168   2            string++;
 169   2          }
 170   1      }
 171          
 172          void initial(void)
 173          {
 174   1          delay(15000);
 175   1      
 176   1          WriteInst4bits(0x30); 
 177   1          delay(4100);
 178   1      
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 4   

 179   1          WriteInst4bits(0x30); 
 180   1          delay(100);
 181   1      
 182   1          WriteInst4bits(0x30); 
 183   1          delay(100);
 184   1      
 185   1          WriteInst4bits(0x20); 
 186   1      
 187   1          WriteInst(0x28); 
 188   1          WriteInst(0x08); 
 189   1          WriteInst(0x01); 
 190   1          WriteInst(0x06); 
 191   1          WriteInst(0x0E); 
 192   1          WriteInst(0x0C);  
 193   1      }
 194          
 195          void CG_RAM_write(unsigned char* ptr)
 196          {
 197   1          WriteInst(0x40);
 198   1          while(*ptr)
 199   1          {
 200   2              WriteData(*ptr++);
 201   2          }
 202   1      }
 203          
 204          void dis_p(char row,column)
 205          {
 206   1          char change_p;
 207   1          row--;column--;
 208   1          change_p = 0x80 + (row*0x40 + column);
 209   1          WriteInst(change_p);
 210   1      }
 211          void WriteNum(unsigned char Num)
 212          {
 213   1          WriteData(Num + '0');
 214   1      }
 215          
 216          void WriteFloat(float T,unsigned char row,unsigned char column)
 217          {
 218   1          unsigned char Temp_H[3];
 219   1          unsigned char Temp_L[4];
 220   1          
 221   1          if(T<0)
 222   1          {
 223   2              dis_p(row,column);
 224   2              WriteString("-");
 225   2              T = -T;
 226   2          }
 227   1          else
 228   1          {
 229   2              dis_p(row,column);
 230   2              WriteString("+");
 231   2          }
 232   1          
 233   1          Temp_H[0] = (unsigned int)T / 100  % 10;
 234   1          Temp_H[1] = (unsigned int)T / 10 % 10;
 235   1          Temp_H[2] = (unsigned int)T / 1 % 10;
 236   1          dis_p(row,column+1);
 237   1          WriteData(Temp_H[0] + '0');
 238   1          dis_p(row,column+2);
 239   1          WriteData(Temp_H[1] + '0');
 240   1          dis_p(row,column+3);
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 5   

 241   1          WriteData(Temp_H[2] + '0');
 242   1          dis_p(row,column+4);
 243   1          WriteString(".");
 244   1          Temp_L[0] = ( (unsigned long)(T*10000)%10000 ) /1000 %10;
 245   1          Temp_L[1] = ( (unsigned long)(T*10000)%10000 ) /100 %10;
 246   1          Temp_L[2] = ( (unsigned long)(T*10000)%10000 ) /10 %10;
 247   1          Temp_L[3] = ( (unsigned long)(T*10000)%10000 ) /1 %10;
 248   1          dis_p(row,column+5);
 249   1          WriteData(Temp_L[0] + '0');
 250   1          dis_p(row,column+6);
 251   1          WriteData(Temp_L[1] + '0');
 252   1          dis_p(row,column+7);
 253   1          WriteData(Temp_L[2] + '0');
 254   1          dis_p(row,column+8);
 255   1          WriteData(Temp_L[3] + '0');
 256   1      }
 257          //---------------
 258          
 259          //---ds18b20 OneWire-----
 260          sbit OneWire_DQ = P3^7;
 261          
 262          //ds18b20初始化為先拉高再拉低後，延遲480微秒後，再釋放
 263          unsigned char OneWire_Init(void)
 264          {
 265   1          unsigned char i;
 266   1          unsigned char AckBit;
 267   1          OneWire_DQ = 1;
 268   1          OneWire_DQ = 0;
 269   1          
 270   1          i = 247; while(--i); //delay 500us(480us)
 271   1        
 272   1          OneWire_DQ = 1;
 273   1        
 274   1          i = 32; while(--i); // delay 70us(60~240us)
 275   1          
 276   1          AckBit = OneWire_DQ;
 277   1        
 278   1          i = 247; while(--i); //delay 500us(480us)
 279   1        
 280   1          return AckBit;
 281   1      }
 282          
 283          void OneWire_SendBit(unsigned char Bit)
 284          {
 285   1          unsigned char i;
 286   1      
 287   1          OneWire_DQ = 0;
 288   1          i = 4; while(--i);  // 10u
 289   1          OneWire_DQ = Bit;
 290   1          i = 24; while(--i); // 50u
 291   1          OneWire_DQ = 1;
 292   1      }
 293          
 294          unsigned char OneWire_ReceiveBit(void)
 295          {
 296   1          unsigned char Bit;
 297   1          unsigned char i;
 298   1      
 299   1          OneWire_DQ = 0;
 300   1          i = 2; while(--i);  // 5u
 301   1          OneWire_DQ = 1;
 302   1          i = 2; while(--i);  // 5u
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 6   

 303   1          Bit = OneWire_DQ;
 304   1          i = 24; while(--i); // 50u
 305   1      
 306   1          return Bit;
 307   1      }
 308          
 309          void OneWire_SendByte(unsigned char Byte)
 310          {
 311   1          unsigned char i;
 312   1          for(i = 0 ; i < 8 ; i ++)
 313   1          {
 314   2              OneWire_SendBit(Byte & (0x01 << i));//低位先行
 315   2          }
 316   1      }
 317          
 318          unsigned char OneWire_ReceiveByte(void)
 319          {
 320   1          unsigned char i;
 321   1          unsigned char Byte = 0x00;
 322   1          for(i = 0 ; i < 8 ; i ++)
 323   1          {
 324   2              if(OneWire_ReceiveBit())
 325   2              {
 326   3                  Byte |= 0x01 << i;
 327   3              }
 328   2          }
 329   1          return Byte;
 330   1      }
 331          
 332          //---------------
 333          
 334          //---DS18B20-----
 335          void DS18B20_ConvertT(void)
 336          {
 337   1          OneWire_Init();
 338   1          OneWire_SendByte(0xCC);
 339   1          OneWire_SendByte(0x44);
 340   1      
 341   1      }
 342          float DS18B20_ReadT(void)
 343          {
 344   1          unsigned char TLSB,TMSB;
 345   1          int Temp;
 346   1          float T;
 347   1          OneWire_Init();
 348   1          OneWire_SendByte(0xCC);
 349   1          OneWire_SendByte(0xBE);
 350   1          TLSB = OneWire_ReceiveByte();
 351   1          TMSB = OneWire_ReceiveByte();
 352   1          Temp = (TMSB<<8) | TLSB;
 353   1          T = Temp / 16.0;//第4bit開始才是整數部分
 354   1          return T;
 355   1      }
 356          
 357          //---------------
 358          
 359          //----UART
 360          void UART_Init(void) {
 361   1          TMOD |= 0x20; // Timer1 模式 2 (自動重載)
 362   1          TH1 = 243; // 波特率 4800 
 363   1          PCON = 0x80;
 364   1          TR1 = 1; // 啟動 Timer1
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 7   

 365   1          SCON = 0x40;
 366   1      }
 367          void UART_Transmit(unsigned char data_) {
 368   1          EA = 0;
 369   1        
 370   1          SBUF = data_; // 載入 UART 資料寄存器
 371   1          while (TI == 0); // 等待傳送完成
 372   1          TI = 0; // 清除傳送標誌
 373   1        
 374   1        
 375   1          EA = 1;
 376   1      }
 377          
 378          
 379          //-------
 380          
 381          void Timer0_Init(void)
 382          {
 383   1          EA = 1; ET0 = 1;
 384   1      
 385   1          TMOD=0x01; 
 386   1      
 387   1          TH0 = (65536 - dutytime_Servo) / 256;
 388   1          TL0 = (65536 - dutytime_Servo) % 256;
 389   1      
 390   1          TR0=1;
 391   1      }
 392          
 393          void INT_Init(void)
 394          {
 395   1          EA  = 1;
 396   1          EX0 = 1;IT0 = 1;
 397   1          EX1 = 1;IT1 = 1;
 398   1          IP  = 0x10;
 399   1          P3_2 = 1;//當輸入時拉成高態
 400   1          P3_3 = 1;//當輸入時拉成高態
 401   1      }
 402          
 403          void int0(void) interrupt 0{
 404   1          flag1 = 1;
 405   1      }
 406          
 407          void timer0_isr(void) interrupt 1{
 408   1      
 409   1          TR0 = 0;
 410   1          
 411   1          if(P2_0==1){
 412   2              temp_Servo = (65536-toff_Servo); 
 413   2            
 414   2              TH0= temp_Servo / 256;
 415   2              TL0= temp_Servo % 256;
 416   2      
 417   2              P2_0=0;
 418   2          }
 419   1          else{
 420   2              temp_Servo = (65536-ton_Servo);
 421   2            
 422   2              TH0=temp_Servo / 256;
 423   2              TL0=temp_Servo % 256;
 424   2      
 425   2              P2_0=1;
 426   2          }
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 8   

 427   1          
 428   1          
 429   1          TR0 = 1;
 430   1      }
 431          
 432          void int1(void) interrupt 2{
 433   1          flag2 = 1;
 434   1      }
 435          
 436          
 437          float T;
 438          
 439          
 440          void main(void)
 441          {
 442   1          //避免讀出默認值
 443   1          DS18B20_ConvertT();
 444   1          delay(60000);
 445   1        
 446   1          INT_Init();
 447   1          Timer0_Init();
 448   1            
 449   1      
 450   1          initial();
 451   1          dis_p(1,1);
 452   1          WriteString("TEMP:");
 453   1          dis_p(2,9);
 454   1          WriteString("Right V");
 455   1          dis_p(2,1);
 456   1          WriteString("Left V");
 457   1      
 458   1          
 459   1          while(1)
 460   1          {
 461   2            
 462   2            DS18B20_ConvertT();
 463   2            T = DS18B20_ReadT();
 464   2            WriteFloat(T,1,7);
 465   2            
 466   2            
 467   2            if(flag1 == 0 && flag2 == 0)//呼吸窗模式
 468   2            {
 469   3                // 20~24度 對應 1200~2200 ton_Servo
 470   3                ton_Servo = 250*(T-2)-3800;
 471   3                // 傳送伺服角度高位與低位
 472   3                UART_Transmit(0x12); // 傳送高位
 473   3                //UART_Transmit(ton_Servo & 0xFF); // 傳送低位
 474   3                delay(50000); // 角度更新間隔
 475   3            }
 476   2            else
 477   2            {
 478   3                ton_Servo = 2200; //警報時全開
 479   3              
 480   3                LED = 0x0f;
 481   3                BUZZER = 1;
 482   3                delay(5000);
 483   3                                                
 484   3                LED = 0xf0;
 485   3                BUZZER = 0;
 486   3                delay(5000);
 487   3                
 488   3                if(flag1 == 1)
C51 COMPILER V9.51   TEST_COMBINE                                                          02/15/2025 19:16:22 PAGE 9   

 489   3                {
 490   4                    dis_p(2,9);
 491   4                    WriteString("Right X");
 492   4                }
 493   3                if(flag2 == 1)
 494   3                {
 495   4                    dis_p(2,1);
 496   4                    WriteString("Left X");
 497   4                }
 498   3            }
 499   2            
 500   2            
 501   2          }//end while
 502   1      }//end main
 503          
 504          
 505          
 506          
 507          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1647    ----
   CONSTANT SIZE    =     42    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
